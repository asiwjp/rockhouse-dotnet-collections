using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace RockHouse.Collections
{
    /// <summary>
    /// Provides utility methods for the IEnumerable.
    /// </summary>
    public static class EnumerableUtils
    {
        /// <summary>
        /// Get the number of elements in the enumerable.
        /// It differs from Linq's Count() in that it tolerates null.
        /// </summary>
        /// <param name="enumerable">An instance of a enumerable. Or null.</param>
        /// <returns>The number of elements in the enumerable, 0 if null.</returns>
        public static int Count(IEnumerable? enumerable)
        {
            if (TryGetNonEnumeratedCount(enumerable, out var count))
            {
                return count;
            }

            checked
            {
                var e = enumerable.GetEnumerator();
                while (e.MoveNext())
                {
                    count++;
                }
            }
            return count;
        }

        /// <summary>
        /// Returns an empty enumerable if the specified enumerable is null or empty.
        /// </summary>
        /// <typeparam name="T">The type of elements.</typeparam>
        /// <param name="enumerable">Target to determine if it is null or not.</param>
        /// <returns>If the specified enumerable is null or empty, empty IEnumerable is returned. Otherwise, the original enumerable is returned as is.</returns>
        public static IEnumerable<T> DefaultIfEmpty<T>(IEnumerable<T>? enumerable)
        {
            return DefaultIfEmpty(enumerable, () => Enumerable.Empty<T>());
        }

        /// <summary>
        /// Returns an default enumerable if the specified enumerable is null or empty.
        /// </summary>
        /// <typeparam name="T">The type of elements.</typeparam>
        /// <param name="enumerable">Target to determine if it is null or not.</param>
        /// <param name="defaultEnumerable">The default enumerable.</param>
        /// <returns>If the specified enumerable is null or empty, defaultEnumerable is returned. Otherwise, the original enumerable is returned as is.</returns>
        public static IEnumerable<T> DefaultIfEmpty<T>(IEnumerable<T>? enumerable, IEnumerable<T> defaultEnumerable)
        {
            return DefaultIfEmpty(enumerable, () => defaultEnumerable);
        }

        /// <summary>
        /// Returns an default enumerable if the specified enumerable is null or empty.
        /// </summary>
        /// <typeparam name="T">The type of elements.</typeparam>
        /// <param name="enumerable">Target to determine if it is null or not.</param>
        /// <param name="factory">Factory functor to generate default enumerable.</param>
        /// <returns>If the specified enumerable is null or empty, the default value generated by the factory is returned. Otherwise, the original enumerable is returned as is.</returns>
        public static IEnumerable<T> DefaultIfEmpty<T>(IEnumerable<T>? enumerable, Func<IEnumerable<T>> factory)
        {
            if (factory == null)
            {
                throw new ArgumentNullException(nameof(factory));
            }

            if (IsEmpty(enumerable))
            {
                return factory();
            }
            return enumerable;
        }

        /// <summary>
        /// Returns an empty IEnumerable if the specified enumerable is null.
        /// </summary>
        /// <typeparam name="T">The type of elements.</typeparam>
        /// <param name="enumerable">Target to determine if it is null or not.</param>
        /// <returns>If the specified enumerable is NULL, an empty IEnumerable is returned. Otherwise, the specified enumerable are returned as is.</returns>
        public static IEnumerable<T> EmptyIfNull<T>(IEnumerable<T>? enumerable)
        {
            if (enumerable == null)
            {
                return Enumerable.Empty<T>();
            }
            return enumerable;
        }

        /// <summary>
        /// Determines if the enumerable is empty or not.
        /// It differs from Linq's Any() in that it tolerates null.
        /// </summary>
        /// <param name="enumerable">An instance of a enumerable. Or null.</param>
        /// <returns>True if the enumerable is null or the number of elements in the enumerable is zero. otherwise False.</returns>
        public static bool IsEmpty(IEnumerable? enumerable)
        {
            if (TryGetNonEnumeratedCount(enumerable, out var count))
            {
                return count == 0;
            }

            return HasElement(enumerable);

            static bool HasElement(IEnumerable e)
            {
                return e.GetEnumerator().MoveNext();
            }
        }

        /// <summary>
        /// Determines if the enumerable is empty or not.
        /// </summary>
        /// <param name="enumerable">An instance of a enumerable. Or null.</param>
        /// <returns>True if the number of elements in the enumerable is non-zero, false if the number of elements is zero or the enumerable is null.</returns>
        public static bool IsNotEmpty(IEnumerable? enumerable)
        {
            return !IsEmpty(enumerable);
        }

        /// <summary>
        /// Returns the number of elements if and only if it is possible to obtain the number of elements without enumerating.
        /// This method provides behavior roughly equivalent to Enumerable.TryGetNonEnumeratedCount(&lt;TSource&gt;) exposed in .NET6 and later, but allows null.
        /// </summary>
        /// <param name="enumerable"></param>
        /// <param name="count"></param>
        /// <returns></returns>
        public static bool TryGetNonEnumeratedCount(IEnumerable? enumerable, out int count)
        {
            if (enumerable == null)
            {
                count = 0;
                return true;
            }

            if (enumerable is string str)
            {
                count = str.Length;
                return true;
            }

            if (enumerable is ICollection c)
            {
                count = c.Count;
                return true;
            }

            count = 0;
            return false;
        }
    }
}
